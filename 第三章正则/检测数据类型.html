<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
    //1.typeof 用来检测数据类型的运算符
    // console.log(typeof 12);//
    // console.log(typeof true);//
    //console.log(typeof undefined);//
    // var num="zhuxp";
    // console.log(typeof num);// 字符串中包含了对应的数据类型
    //number string boolean  undefined function  object
    //局限性:typeof null ->object  空对象
    //不能具体细分是数组还是正则还是对象中的其他值,因为用这个检测数据类型 对对象数据类型中的所有的 值最后返回的都是object
    // console.log(typeof  typeof  typeof  function () {
    //
    // });//-->string
    // function fn(num1,num2) {
    //     // if(typeof  num2==="undefined"){
    //     //     num2=0;
    //     // }
    //     num2=num2||0;//这两个不一样
    // }
    // fn(10,false);
    // function fn(cb) {
    //     //typeof  cb==="function"?cb():null;
    //     cb && cb();
    // };
    // fn(function () {
    //
    // })
    //使用typeof检测数据类型 首先返回的是一个字符串
    //2. instanceof 检测某一个实例是否属于某个类
//局限性:很多
    //对于基本数据类型来说 字面量方式创建出来的结果和实例创建出来的结果是有一定区别的
    //严格意义上来讲只有实例创建出来的结果才是标准的对象数据类型也是标准的Number这个类的一个实例
    //对于字面量创建出来的结果是基本数据类型值不是严谨的实例，但是由于js松散特点 导致它可以使用Number.prototype上的提供的方法
    // var obj=[12,23];
    // console.log(obj instanceof Array);//true
  //   // console.log(obj instanceof RegExp);//false
  //   var ary=[];
  //   console.log(ary instanceof Array);//true
  //   console.log(ary instanceof Object);//true
  //   function fn(){}
  //   console.log(fn instanceof Function);//true
  //   console.log(fn instanceof Object);//true
  // console.log(1 instanceof Number);//false
  // console.log("" instanceof String);//false
  //   console.log(new Number(1) instanceof Number);//true
  // function Fn() {
  //
  // }
  // Fn.prototype=new Array;//原型继承让子类的一个原型等于父类的一个实例
  //   var f=new Fn;
  //   console.log(f instanceof Array);//true 不准确 它不是数组
    //自己写一个类，作用是创建一个类数组 但是可以使用数组的方法

    //3.constructor构造函数和instanceof非常相似
    // constructor检测Object和instanceof不一样
    //constructor这个可以处理基本数据类型
    //局限性:我们可以把类的原型重写,在重写的过程中可能把constructor覆盖了，这样检测的结果就不准确了

  //   var obj=[];
  //   console.log(obj.constructor===Array);//true  是一个数组
  // var num=1;
  //   console.log(num.constructor===Number);//true 这个可以处理基本数据类型
  //   var reg=/^$/;
    // console.log(num.constructor===RegExp);//true
    // console.log(num.constructor===Object);//false
//对于特殊数据类型null undefined他们所属的类是Null和Undefined但是浏览器把这两个类保护起来了,
    //不允许我们在外面访问使用

    //4.Object.prototype.toString.call();// 最准确最常用的方式
    //首先获取Object上原型的toString方法改变this关键字的指向
    //1.toString的理解:
    //->对于Number String Boolean Array RegExp Date  Function 原型上的toString方法都是把当前的数据类型转化为字符串
   // console.log(Math.toString());//[Obejct Math]
  //  console.log((1).toString());//转化为字符串如果传入参数2 8 16 10表示转化为进制
    // null undefined 没有这个toString方法
    //console.log([1,23,3].toString())
    //console.log((1).__proto__.__proto__.toString());//Object.prototype.toString  [object Object]

//var obj={name:"zhuxp"};
//console.log(obj.toString());//this->obj  返回的是obj所属类的信息[object Object]第一个表示当前实例对象数据类型(固定死的),第二个是obj所属的类是Object
// var ary=[];
// console.log(Object.prototype.toString.call(ary));//[object Array]
// console.log(Object.prototype.toString.call(/^$/));//[object RegExp]
// console.log(({}).toString.call(new Date));//[object Date]
//
//     console.log(Object.prototype.toString.call(1));
//     console.log(Object.prototype.toString.call("12"));
//     console.log(Object.prototype.toString.call(true));
//     console.log(Object.prototype.toString.call(null));
//     console.log(Object.prototype.toString.call(undefined));
//     console.log(Object.prototype.toString.call(function () {
//     }));
    // [object Number]
    // [object String]
    // [object Boolean]
    // [object Null]
    // [object Undefined]
    // [object Function]
    // var ary=[];
    // var reg=/^\[object Array\]$/;
    // console.log(reg.test(Object.prototype.toString.call(ary)));//true
    // function Fn(){}
    // Fn.prototype=new Array;//原型继承让子类的一个原型等于父类的一个实例
    //   var f=new Fn;
    //   console.log(f instanceof Array);//false
    // var reg=/^\[object Array\]$/;
    // console.log(reg.test(Object.prototype.toString.call(f)));//true
</script>
</body>
</html>